# Adaptate

Dynamic and Adaptable Model Validator Using Zod, Interoperable with OpenAPI

## Overview

`adaptate` is a dynamic and adaptable model validator that leverages the power of Zod for schema validation and is interoperable with OpenAPI. This library allows you to define, validate, and transform schemas seamlessly.

## Features

- Make schemas required based on configuration
- Apply conditional requirements to schemas
- Convert JSON Schema to Zod schemas
- Convert Zod schemas to OpenAPI schemas

## Installation

To install the library, use npm or yarn:

```sh
npm install adaptate
# or
yarn add adaptate
```

## Usage

So what this package Sells, sorry solves while there are so packages of [ecosystem](https://zod.dev/?id=ecosystem) out there.

#### The pitch for a common use case:

In real world web applications (for the sake of brevity assuming component-oriented apps/page where view/page is divided as composed components), Developers run into a untreated and often unnoticed issue of data(props) flow into components.

Imagine a hypothetical page component

```tsx
{
  /* I will check authentication and authorization to access this page
    And put necessary session information and render the content if it is success
  */
}
<Page>
  <Sidebar>
    <Navigations />
  </Sidebar>
  {/* I will fetch the business data from a API endpoint, say, `/api/participants` once and
      Pass it down or put it in global store. This data, either as whole (not likely)
      Or partially will be used by 1000 of components in this page
      And from the same data model each component requires different properties
  */}
  <Main>
    <Content>
      <ComponentOne
        data={
          'I need so and so props from the parent to behave and function as expected'
        }
      />
      <ComponentTwo
        data={
          'I need only these props from the parent to behave and function as expected'
        }
      />
      {/* Oops! I am also used in some other page
          Where the same data model have more properties
          And the data comes from another endpoint, say, `/api/participants/participantId`.
          And I am one of the most used component and many developers individually
          Extend the component based on requirements. Yes communication loop and forgetting
          That it is also used in some other place is problem when working on the component
          In isolation
        */}
      <ComponentThree
        data={
          'I need all these props from the parent to behave and function as expected'
        }
      />
      <ComponentFour
        data={
          'I need everything from the parent to behave and function as expected'
        }
      />
    </Content>
  </Main>
</Page>;
```

## Make Required Schema Based on Configuration

You can make a Zod schema required based on a configuration (components need) using the makeSchemaRequired function.

```ts
import { z } from 'zod';
import { makeSchemaRequired } from 'adaptate';

const schema = z.object({
  name: z.string().optional(),
  age: z.number().optional(),
  address: z
    .object({
      street: z.string().optional(),
      city: z.string().optional(),
    })
    .optional(),
});

const config = {
  name: true,
  age: true,
  address: {
    city: true,
  },
};

const updatedSchema = makeSchemaRequired(schema, config);

updatedSchema.parse({
  name: 'Davin',
  age: 30,
  address: {
    city: 'Pettit',
  },
}); // will pass

updatedSchema.parse({
  name: 'Davin',
  age: 30,
  address: {
    street: 'First Avenue',
  },
}); // will throw as required city property is missing
```

## What more cane be cooked?

<details>
<summary>Apply Conditional Requirements (needs improvement)</summary>

You can apply conditional requirements to a Zod schema using the applyConditionalRequirements function.\* (Didn't work in improving it, generated by ChatGPT as is)

```ts
import { z } from 'zod';
import { applyConditionalRequirements } from 'adaptate';

const schema = z.object({
  firstName: z.string().optional(),
  secondName: z.string().optional(),
  age: z.number().optional(),
  address: z
    .object({
      street: z.string().optional(),
      city: z.string().optional(),
    })
    .optional(),
  title: z.string().optional(),
});

const config = {
  age: true,
  // explicit
  firstName: {
    requiredIf: (data: any) => data.age > 18,
  },
  // or implicit
  secondName: (data) => !!data.firstName,
};

const data = { age: 20 };

const updatedSchema = applyConditionalRequirements(schema, config, data);
```

</details>

<details>
<summary>Converting OpenAPI Schema to Zod Schema (most commonly needed)</summary>

The utility is in early stage and not one to one. For complete and advanced use case check [json-schema-to-zod](https://snyk.io/advisor/npm-package/json-schema-to-zod)

```ts
import { openAPISchemaToZod } from 'adaptate';

const openAPISchema = {
  type: 'object',
  required:
    - age
  properties: {
    name: { type: 'string' },
    age: { type: 'number' },
  },
};

const zodSchema = openAPISchemaToZod(openAPISchema);

```

</details>

<details>
  <summary>Converting Zod Schema to OpenAPI Schema</summary>

The utility is in early stage and not one to one. For complete and advanced use case check [zod-to-json-schema](https://snyk.io/advisor/npm-package/zod-to-json-schema)

```ts
import { z } from 'zod';
import { zodToOpenAPISchema } from 'adaptate';

const zodSchema = z.object({
  name: z.string(),
  age: z.number(),
});

const openAPISchema = zodToOpenAPISchema(zodSchema);
```

</details>

<details>
  <summary>
    Loading schema directly form OpenAPI yml spec file (imaginary one)
  </summary>

It is not exported something similar for your use case, you could build your own yml loader, spec parser that take care of usage of `$ref`.

```ts
// loadAndResolveYAML.ts
import fs from 'node:fs';
import path, { dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

import SwaggerParser from '@apidevtools/swagger-parser';
import yaml from 'js-yaml';

export async function loadAndResolveYAML(
  fileURL: string,
  relativePath: string
) {
  try {
    let fileURLPath = fileURLToPath(fileURL);
    let callerDirectoryName = dirname(fileURLPath);
    let yamlFilePath = path.resolve(callerDirectoryName, relativePath);
    const openapiDocument = yaml.load(
      fs.readFileSync(yamlFilePath, 'utf8')
    ) as string;

    const dereferenced = await SwaggerParser.dereference(openapiDocument);

    // For debugging uncomment this!
    // console.log(JSON.stringify(dereferenced, null, 2));

    return dereferenced;
  } catch (error) {
    console.error('Error:', error);
  }
}
```

Example usage

```ts
let dataLoadedFromYAML = await loadAndResolveYAML(
  import.meta.url,
  '../fixtures/base-schema.yml' // relative path to spec yml file from where it is called
);
let dataZodSchema = openAPISchemaToZod(
  dataLoadedFromYAML['components']['schemas']['Category']
);
```

</details>

## Credits

I have attempted to recreate what I have done at work with the help of ChatGPT Canvas model, the problem is simple and yet enough to test the muscle of code generators where solution involved recursion and dealing with deep and nested data structure. It produced bugs and those are hard to figure it out even for humans in the recursion context such as using correct apis of the library (`required` instead of `unwrap`). I have tried to generate minimal project with basic toolings. It did a decent work.

<details>
<summary> Suggestion vs Final edits</summary>

```diff
 import { z, ZodObject, ZodArray, ZodTypeAny } from 'zod';

-export function makeSchemaRequired(schema: ZodTypeAny, config: any, parentData: any = {}) {
-  const schemaWithConditionalRequirements = applyConditionalRequirements(schema, config, parentData);
-
-  if (schemaWithConditionalRequirements instanceof ZodObject && typeof config === 'object' && !Array.isArray(config)) {
-    const shape = schemaWithConditionalRequirements.shape;
-    const newShape = Object.fromEntries(
-      Object.entries(shape).map(([key, value]) => {
-        if (config[key] === true) {
-          return [key, value.required()];
-        } else if (typeof config[key] === 'object') {
-          return [key, makeSchemaRequired(value, config[key], parentData)];
-        }
-        return [key, value];
-      })
-    );
-    return z.object(newShape).required();
-  } else if (schemaWithConditionalRequirements instanceof ZodArray && config['*']) {
-    const elementSchema = schemaWithConditionalRequirements.element;
-    return z.array(makeSchemaRequired(elementSchema, config['*'], parentData));
-  }
-  return schemaWithConditionalRequirements;
+export function makeSchemaRequired(
+  schema: ZodTypeAny,
+  config: Config
+): ZodTypeAny {
+  function extendSchema(
+    partialSchema: ZodObject<any>,
+    partialConfig: Config
+  ): ZodObject<any> {
+    const unwrappedPartialSchema = partialSchema?.isOptional?.()
+      ? // @ts-ignore
+        partialSchema.unwrap()
+      : partialSchema;
+
+    if (
+      unwrappedPartialSchema instanceof ZodObject &&
+      typeof partialConfig === 'object' &&
+      !Array.isArray(partialConfig)
+    ) {
+      const shape = unwrappedPartialSchema.shape;
+      // @ts-ignore
+      const newShape = Object.fromEntries(
+        // @ts-ignore
+        Object.entries(shape).map(([key, value]) => {
+          // @ts-ignore
+          let unwrappedValue = value?.isOptional?.() ? value.unwrap() : value;
+          if (partialConfig[key] === true) {
+            // @ts-ignore
+            return [key, unwrappedValue];
+          } else if (typeof partialConfig[key] === 'object') {
+            // @ts-ignore
+            return [key, extendSchema(value, partialConfig[key])];
+          }
+          return [key, value];
+        })
+      );
+
+      let updatedPartialSchema = z.object(newShape);
+
+      // @ts-ignore
+      return unwrappedPartialSchema.merge(updatedPartialSchema);
+    }
+
+    if (unwrappedPartialSchema instanceof ZodArray && partialConfig['*']) {
+      const elementSchema = unwrappedPartialSchema.element as ZodObject<any>;
+
+      let updatedPartialSchema = z.array(
+        extendSchema(elementSchema, partialConfig['*'])
+      );
+
+      // @ts-ignore
+      return updatedPartialSchema;
+    }
+    return unwrappedPartialSchema;
+  }
+
+  let updatedSchema = schema;
+
+  if (schema instanceof ZodArray && config['*']) {
+    // @ts-ignore
+    updatedSchema = makeSchemaRequired(schema.element, config['*']);
+    updatedSchema = z.array(schema.element.merge(updatedSchema));
+  } else if (schema instanceof ZodObject) {
+    // @ts-ignore
+    updatedSchema = extendSchema(schema, config);
+    // @ts-ignore
+    updatedSchema = schema.merge(updatedSchema);
+  } else {
+    throw new Error('The given schema must be a Zod object.');
+  }
+
+  return updatedSchema;
 }
```

</details>

[Full conversation with ChatGPT Canvas](https://chatgpt.com/share/6728eb4e-07f8-8005-b586-c4b8ee0e798c)

### So why?

#### The Background

At [Oneflow AB](https://oneflow.com), we faced a situation where a component was used on two different pages, each receiving data from different endpoints. This led to discrepancies in the properties of the same model for valid reasons. To avoid breaking the app, I have built a run-time validation library that abstracted business data extensively . Although it wasn't completely dynamic, it supported specifying business entities, types such as `collection` or `entity`, and reusable specifications like `relations`. It also included React-specific hooks that worked seamlessly with error boundaries. This effort aims to create a more generic solution that can be extended to various use cases.
